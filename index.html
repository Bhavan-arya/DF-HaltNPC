<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HaltNPC • DF</title>
    <style>
        :root {
            --bg-color: #050505;
            --accent: #4af;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-color); font-family: 'Courier New', Courier, monospace; color: white; }
        
        /* UI Overlay */
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: -1px; font-size: 1.5rem; }
        p { opacity: 0.7; font-size: 0.8rem; max-width: 300px; margin-top: 10px; }

        /* Upload Button */
        .upload-btn {
            pointer-events: auto;
            display: inline-block;
            margin-top: 20px;
            padding: 12px 24px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
        }
        .upload-btn:hover { background: var(--accent); border-color: var(--accent); color: #000; }
        input[type="file"] { display: none; }

        /* Loading Spinner */
        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent);
            display: none;
            font-size: 2rem;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* Instructions */
        .controls {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            text-align: center; pointer-events: none; opacity: 0.5; font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Diamonds are forever</h1>
        <p>Upload an image to transform it into a 3D ASCII particle cloud. Scroll to morph between Globe and Plane.</p>
        
        <label class="upload-btn">
            Upload Image
            <input type="file" id="fileInput" accept="image/*">
        </label>
    </div>

    <div id="loader">Processing...</div>
    <div class="controls">Scroll to Morph • Drag to Rotate • Hover to Disrupt</div>

    <!-- Import Three.js as an ES Module -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const DENSITY = 140; // Higher = more particles (careful with performance)
        const PARTICLE_SIZE = 12.0;
        const ASCII_CHARS = " .:-=+*#%@"; // Darkest to brightess

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- ASCII TEXTURE GENERATOR ---
        // Creates a sprite sheet of characters to use on the GPU
        function createAsciiTexture() {
            const canvas = document.createElement('canvas');
            const size = 64; // Size of one character block
            const cols = ASCII_CHARS.length;
            canvas.width = size * cols;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.font = `bold ${size * 0.75}px monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#ffffff";

            for (let i = 0; i < cols; i++) {
                ctx.fillText(ASCII_CHARS[i], i * size + size / 2, size / 2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            return texture;
        }
        
        const asciiTexture = createAsciiTexture();

        // --- SHADERS ---
        // The magic happens here: GPU handles positions and ASCII mapping
        const vertexShader = `
            uniform float uTime;
            uniform float uMorph; // 0 = Globe, 1 = Plane
            uniform float uSize;
            uniform vec3 uMouse;
            uniform float uHover;
            
            attribute vec3 aPositionGlobe;
            attribute vec3 aPositionPlane;
            attribute float aCharIndex;
            attribute vec3 aColor;

            varying float vCharIndex;
            varying vec3 vColor;

            // Simplex noise function for "organic" movement
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) { 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0);
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ ); 
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vCharIndex = aCharIndex;
                vColor = aColor;

                // Mix between sphere and plane positions
                vec3 pos = mix(aPositionGlobe, aPositionPlane, uMorph);

                // Add subtle noise movement
                float noiseVal = snoise(vec3(pos.x * 0.1, pos.y * 0.1, uTime * 0.5));
                pos += noiseVal * 0.5;

                // Mouse repulsion
                float dist = distance(pos.xy, uMouse.xy);
                float radius = 20.0;
                if(dist < radius && uMorph > 0.5) { // Only repel when mostly flat
                    vec3 dir = normalize(pos - vec3(uMouse.xy, 0.0));
                    pos += dir * (radius - dist) * 0.5;
                }

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = uSize * (300.0 / -mvPosition.z); // Scale by depth
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform float uCharCount;
            
            varying float vCharIndex;
            varying vec3 vColor;

            void main() {
                // Determine which character to use
                float charWidth = 1.0 / uCharCount;
                vec2 uv = gl_PointCoord;
                
                // Calculate UV for the specific character in the sprite sheet
                // uv.x needs to be squished and shifted
                float u = uv.x * charWidth + (vCharIndex * charWidth);
                
                vec4 texColor = texture2D(uTexture, vec2(u, uv.y));
                
                if (texColor.a < 0.5) discard; // Transparent background
                
                gl_FragColor = vec4(vColor, 1.0) * texColor;
            }
        `;

        // --- PARTICLE SYSTEM ---
        let particles;
        let geometry;
        let material;

        function initParticles(imageData, width, height) {
            if (particles) scene.remove(particles);

            const count = width * height;
            geometry = new THREE.BufferGeometry();
            
            const positionsGlobe = new Float32Array(count * 3);
            const positionsPlane = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const charIndices = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                // 1. Plane Position (The Image)
                const x = (i % width);
                const y = Math.floor(i / width);
                // Center the image
                positionsPlane[i * 3] = x - width / 2;
                positionsPlane[i * 3 + 1] = -(y - height / 2); // Flip Y
                positionsPlane[i * 3 + 2] = 0;

                // 2. Globe Position (The Start)
                // Random point on sphere surface
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                const r = width * 0.6; // Radius based on image width
                
                positionsGlobe[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                positionsGlobe[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                positionsGlobe[i * 3 + 2] = r * Math.cos(phi);

                // 3. Color & Brightness
                const stride = i * 4;
                const rVal = imageData[stride] / 255;
                const gVal = imageData[stride + 1] / 255;
                const bVal = imageData[stride + 2] / 255;
                const brightness = (rVal + gVal + bVal) / 3;

                colors[i * 3] = rVal;
                colors[i * 3 + 1] = gVal;
                colors[i * 3 + 2] = bVal;

                // Map brightness to character index (0 to 9)
                charIndices[i] = Math.floor(brightness * (ASCII_CHARS.length - 1));
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positionsPlane, 3)); // Helper for bounding box
            geometry.setAttribute('aPositionGlobe', new THREE.BufferAttribute(positionsGlobe, 3));
            geometry.setAttribute('aPositionPlane', new THREE.BufferAttribute(positionsPlane, 3));
            geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aCharIndex', new THREE.BufferAttribute(charIndices, 1));

            material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uMorph: { value: 0 }, // Start at Globe
                    uSize: { value: PARTICLE_SIZE },
                    uTexture: { value: asciiTexture },
                    uCharCount: { value: ASCII_CHARS.length },
                    uMouse: { value: new THREE.Vector3(0, 0, 0) }
                },
                transparent: true,
                depthTest: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- IMAGE PROCESSING ---
        function processImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Create a canvas to read pixel data
                    const canvas = document.createElement('canvas');
                    // Downscale for performance (maintain aspect ratio)
                    const aspect = img.width / img.height;
                    const w = DENSITY;
                    const h = Math.round(DENSITY / aspect);
                    
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    
                    const data = ctx.getImageData(0, 0, w, h).data;
                    initParticles(data, w, h);
                    
                    document.getElementById('loader').style.display = 'none';
                    
                    // Reset animation
                    targetMorph = 1; // Auto-animate to plane on load
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- INPUT HANDLING ---
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                document.getElementById('loader').style.display = 'block';
                processImage(e.target.files[0]);
            }
        });

        // Mouse Raycasting helper
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const intersectPoint = new THREE.Vector3();

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Project mouse to 3D plane z=0
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            if (material) {
                material.uniforms.uMouse.value.copy(intersectPoint);
            }
        });

        // Scroll to morph
        let targetMorph = 0;
        let currentMorph = 0;
        window.addEventListener('wheel', (e) => {
            targetMorph += e.deltaY * 0.001;
            targetMorph = Math.max(0, Math.min(1, targetMorph));
        });

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Smooth morph transition
            currentMorph += (targetMorph - currentMorph) * 0.05;

            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uMorph.value = currentMorph;
            }

            // Slight idle rotation when in Globe mode
            if (particles && currentMorph < 0.5) {
                particles.rotation.y = time * 0.1;
            } else if (particles) {
                particles.rotation.y = 0; // Lock rotation when flat
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- INIT DEFAULT IMAGE ---
        // (Optional: Load a placeholder noise or text)
        // For now we just wait for upload.
        
        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>